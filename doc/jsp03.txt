#jsp03

지시자
	1. page
	
	2. include
	
	3. taglibrary
	
	
	2. include
	=> 다른 문서를 현재 파일에 포함시키는 기능을 가진 지시어
	다른 문서와 현재 문서를 하나의 문서로 만드는 기능
	
		형식) 
		<%@ include file="합체파일이름" %>
		
		참고]
			우리가 웹 문서를 만들다보면 여러 페이지에 같은 내용이 중복되어서 들어가는 경우가
			더러있다.
			
			하지만 원칙적으로 jsp문서가 만든 결과를 응답하기때문에
			(요청에 대해서 하나의 응답문서만 응답하므로)
			매 문서마다 동일한 내용이라도 다시 작성해야한다.
			이런 불편함을 조금이나마 덜기 위한 방법으로 제시된 지시어이다.
			
		=> 자주 사용되는 내용은 따로 만들어 놓고 응답 문서에 따로 만들어진 파일을 합쳐서 하나의
		문서로 만드는 방법
		
		주의 ]
			이 작업은 먼저 문서들을 합치고(하나의 문서로 만들고) 
			컴파일을 한다.
			(==> .class 파일을 만든다.)
			만약 먼저 문서들을 하나로 합쳤을 때 문제가 생기면 
			(변수등이 충돌이 나면) 
			에러가 발생한다는 것을 명심하세요
			
			정리 ]
			include 지시자로 두개의 문서를 하나의 문서로 합쳤을 경우
			두 문서에 똑같은 이름의 변수가 만들어질 경우
			하나의 클래스로 합쳐졌을 때 이 변수들이 충돌이 날 수 있기 때문에
			주의해야겠따.
			
	===================================================================================================
	
	스크립트 방식
	==> JSP는 HTML언어가 기본이 되고 필요하면 자바 언어를 
	필요한 위치에 삽입하여 같이 실행하는 문서이다.
	이처럼 다른언어에 포함하여 처리하는 방식을 
	스크립트 방식이라고 한다.
	JSP문서에 자바코드를 삽입하는 방식은 3가지가 있다.
	
	
	1. 스크립트 릿 방식
		=> 일반적인 자바 코드를 포함하는 방식을 의미한다.
			이곳에 기록한 모든 내용은 service함수 안에 포함된다.
			따라서 이곳은 결국 지역적인 역할을 한다.
		
		참고]
			어차피 JSP문서는 여러 문서가 같이 실행되는 것이 아니고
			클라이언트가 요청한 문서 하나만 실행되므로
			클래스가 연결되어서 실행되는 경우는 거의 없다.
			결론적으로 main함수만 있으면 충분하게 그 역할을 한다.
			
		참고]
			JSP문서는 실행을 하면 먼저 자바 클래스로 변환하고
			(.java 파일로 변환) 그것을 컴파일해서 (=> .class 파일이 탄생..)
			실행되어진다.
			이런 클래스를 우리는 서블릿 클래스라고 부른다.
			이때 이것역시 자바의 main 함수 처럼 시작함수가 (진입점함수)존재하는데
			그 역할을 service() 함수가 담당하고 있다.
			
		형식 ]
		<%
			자바 코드 작성...
			
		%>
			
		참고 ]
			스크립트 릿 속에 있는 내용과 HTML 코드 내용은
			같이 service 함수에 코딩이 된다.
			따라서 두가지는 혼용해서 사용할 수 있다.
			다만 자바적인 요소와 HTML적인 요소만 구분해 주면된다.
			
			
	2. 선언자방식
	 	=> 스크립트 릿 방식에서 설명했듯이 JSP는 service()함수 안에서
	 		거의 모든 것이 기술이 되고 실행이 된다.
	 		하지만 가끔은 전역변수나 함수를 만드는 방식이 선언자 방식이다.
	 		
	 		결론적으로 전역변수와 함수를 만드는 기능을 가진 스크립트 방식이다.
	 		(이 안에는 일반적인 명령은 사용할 수 없다.)
	 		
	 		형식 ]
	 			<%!
	 				변수선언
	 				함수제작
	 			%>
	3. 표현자방식
		=> System.out.println()와 같이 
		자바적인 요소(변수, 함수)를 화면에 내용을 출력하기 위한 스크립트이다.
		
	형식 ]
		<%= 출력내용 %>
		
	주의사항 ]
		출력내용은 오직 한개만 출력할 수 있따.
		이것은 System.out.println()도 마찬가지이다.
		=> 문자열 결합을 이용해서 하나의 문자열로 만들어서 
		출력하는 방식을 사용해야 한다.
		
	=====================================================================================
	참고 ]
		주석문
			1. 확장자가 html인 문서에서는 
			<!-- -->
			의 방식으로 html 주석처리 방식을 따른다.
			
			2. 확장자가 jsp인 문서에서는 
				1) html 요소부분에서는  
					<%-- %>의 방식으로 주석문을 달 수 있다. 화면에 보여지지 않는다.
					<!-- --> 화면에 보여준다.
					
				2) 자바적인 요소 부분은 
					//단일행 주석
					/*
						다중행 주석
					*/
				
		==================================================================================
		
	내장객체 
	=> 자주 사용하는 클래스 중 몇가지는 jsp안에서 미리 new 시켜서
	사용할 수있도록 미리 준비해 놓은 것이있다.
	따라서 이것은 new 시킬 필요없이 필요하면 그냥 사용하면 되는 클래스
	내장객체라고 불ㄴ다.
	
	1.out 객체
	Print Writer 클래슬르 미리 new 시켜놓은 내장객체
	
	즉
		printWriter out= new PrintWriter();
		
		이 클래스의 역할은 클라이언트에게 응답하는 문서를 작업하는 기능이다.
		
		<%= %>과 동일한 기능이다.
		
		주요함수 ]
			write()
			flush()
			
		PrintWriter는 JspWriter 클래스로 변환되어서 new 된 경우이다.
		
		
	참고]
		따라서 내장객체는 결국 클래스를 사용하는 것이ㅏㄷ.
		그 클래스 안에서 원하는 함수가 무었인지를 파악하는 것이 좋다.
		
		
	*
	2.request 객체
	=> 클라이언트의 요청 정보를 관리하는 역할을 하는 내장객체이다.
	즉, 요청한 클라이언트의 ip주소, 요청내용 , 부가정보를 알고 싶은 경우
	사용하는 내장객체이다
	
	HttpServletRequest를 이용해서 만들어진 내장객체이다.
	주요함수]
		getParameter()
		=> 서버측에서 클라이언트가 준 부가정보(파라미터) 알아내는 함수
		
			사용형식)
				String ??? = request.getParameter("키값");
				
			주의사항]
				부가정보(파라미터)는 오직 String(문자열)로만 받을 수 있다.
				
				
	getParameterValues()
		형식]
			String[] ?? = request.getParameterValues("키값");
			
			
			
	참고]
		클라이언트가 서버에게 요청하는 방법
		1. GET 방식
			1) 주소 표시줄에 직접 입력해서 요청하는 방법
			2) <a>태그를 이용해서 요청하는 방법
				형식]
					<a href="요청주소">???</a>
					
			3) javascript에서 location객체를 사용해서 요청하는 방법 
				형식]
					location.href= "?????????";
					
			4) form 태그의 method 속성값으로 GET을 설정하고
				form 태그로 요청하는 방법
				형식 ]
					<form method="GET" action="요청주소" name="??????" id="????">
					</form>
					
					
		참고 ]
			GET 방식으로 요청할 때 부가정보(파라미터)를 같이 줄 수 있다.
			예를 들어 게시판 목록보기를 할 때 
			몇 페이지를 보여주세요...
			라고 요청할 수 있다.
			
			형식]
				<a href="요청문서?키값=데이터&키값=데이터&...">내용</a>
				
				주의 ]
					?, = , & 기호 앞뒤에는 절대로 공백이 있어서는 안된다.
		참고]
			GET 방식은 요청 내용이 주소 표시줄에 노출이 되기 때문에
			보안에 취약한 단점이 있다.
			
		참고]
			부가정보(파라미터)에 한글이 들어가면 서버측에서 받을 수 없는 경우가 있따.
			즉, 한글이 깨져서 나온다고들 한다.
			
			해결방법]
			
				1. 그 문서에서만 해결하는 방법
					<%
						request.setCharacterEncoding("UTF-8");
					%>
				2. 모든 문서에서 해결하는 방법 
						server.xml 파일안에 
						<Connector 태그 마지막부분에 URIEncodimg="UTF-8"을 추가해주면 된다.
						
				
		2.POST 방식 
			1) form 태그를 제작해서 요청하는 방법
				=>로그인 폼과 같이 사용자가 필요한 것을 입력
				또는 선택해서 서버에게 전달하는 방식
				
			***
			특징 ]
				반드시 <form> 태그안에 입력태그를 만들어야한다.
				만약 어떤 입력태그가 <form>태그안에 있지 않으면 
				그 태그의 입력된 내용은 서버에 전달되지 않는다.
				
				
			***
			참고 ]
				이때는 반드시 이 폼의 내용을 전달할 도구를 준비해야 한다.
				이 도구를 우리는 submit(제출)도구라고 한다.
				
				제출도구 만드는 방법 ]
				
					1) html로 해결하는 방법
						<input type="submit" value="버튼이름">
						=>모양은 버튼이지만 이버튼을 클릭하면 폼 태그에 감싸진 모든 입력태그의 내용이 
						서버에 전달이 된다.
						
					2) 자바스크립트로 해결하는 방법
						<script type="text/javascript">
							var frm = 폼태그 선택;
							
							frm.submit();
							
						</script>	
		
		from 태그 작성 형식 ]
		
			<form method="POST" action="요청문서">
				필요한 입력태그 준비...
			</form>
			
			참고]
				중요속성
					method
						=> 폼의 데이터를 서버에게 보내는 방법
							GET, POST 중 하나를 선택한다.
							
					action
					=>서버에게 요청할 문서의 주소
					
			참고 ]
				POST 방식은 스트림을 이용해서 서버에게 전달하게 되므로
				주소칸에 그 내용이 나오지 않게 된다.
				따라서 GET방식보다는 보안에 조금 유리하다.
				
			참고 ]
				POST 방식으로 전달하는 데이터의 한글 깨짐 방지하는 방법
				서버가 필터링을 이용해서 인코딩 해줘야한다.
				
				방법 ]
					web.xml 파일을 열고
					
					1. 필터를 등록한다.
						<filter>
					        <filter-name>setCharacterEncodingFilter</filter-name>
					        => 만드는 필터의 이름
					        <filter-class>org.apache.catalina.filters.SetCharacterEncodingFilter</filter-class>
					        => 필터에 사용할 클래스를 지정하는 부분
					        <init-param>
					            <param-name>encoding</param-name>
					            <param-value>UTF-8</param-value>
					        </init-param>
					    </filter>	
				부분을 찾아서 주석을 해제한다.
				
					2. 필터를 적용하는 부분
					web.xml파일에서 
					
				    <filter-mapping>
				        <filter-name>setCharacterEncodingFilter</filter-name>
				        =>만들어진 필터의 이름을 입력하는 부분
				        <url-pattern>/*</url-pattern>
				        => 어떤 요청에 적용을 시킬 것인지 요청패턴을 지정하는 부분
				        	/*의 의미는 모든 요청에 대해서 필터를 적용시키겠다는 의미이다.	
				    </filter-mapping>		
					
					부분을 찾아서 주석을 해제해준다.
					
					
			참고 ]
				<input type="text"
				<input type="password"
				<textarea></textarea>
				의 3가지(입력태그)는 사용자가 입력한 내용이 서버에 전달이 된다.
				하지만 그 이외의 태그들은 화면에 보이는 내용이 전달되지 않고
				value속성으로 지정한 내용이 서버에 전달이 된다.
				결론적으로 입력태그 계열 이외의 태그를 제작할 경우에는 
				반드시 value 속성을 지정해야 한다.
				
			참고]
				만약 같은 폼태그 안에 같은 name 속성값이 여러개 존재하는 경우는 
				모든 데이터가 배열 형태로 전달되어진다.
				
				
				따라서 이 때는
					request.getParameterValues();
				함수를 이용해서 꺼내와야 한다.
				
			참고 ]
				만든 폼이 라디오버튼이거나 체크상자인 경우에는 
				선택된 내용만 서버로 전달된다
				
				특히 체크박스의 경우 선택, 취소로 서버에 절대로 전달되지 않는다.
				
		*
		3. response
			=> 서버가 클라이언트에게 응답하는 정보를 관리하는 내장객체
				
				HttpServletResponse라는 클래스를 이용해서 만들어진 내장객체이다.
				주요함수 ]
					sendRedirect()
					=>서버측에서 강제로 클라이언트의 요청을 변경하는 명령이다.
						즉, 클라이언트는 A라는 문서를 요청했는데 
						서버측에서 강제로 B라는 문서로 응답하는 방법
						
						예를 들어서 게시판 글쓰기를 요청한 경우
						이때 글쓰기 작업이 끝나면 글쓰기 작업에 대한 응답을 하는것이 아니고
						강제로 목록보기 보여주기를 응답하는것이 일반적이다.
						그런데 이때 목록보기도 하나의 요청에 해당을 한다.
						
						이처럼 서버는 가끔 필요하면 클라이언트의 요청(예를 들어 글등록 요청)을
						서버가 다른 요청으로(예를들어 목록보기 요청)으로 바꿔야 할 필요가 있다
						
						
					참고]
						서버가 요청을 바꾸는 방법
							1.Redirect
								=> sendRedirect()
								원래 클라이언트의 요청정보를 모두 잊어버리고 
								완벽하게 새로운 요청으로 처리를 한다.
								
								따라서 원래 클라이언트가 준 정보는 잊어버린 상태가 된다.
								
								새로고침하면 마지막 요청(서버가 변경한 요청)부터 시작을 한다.
								즉, 서버가 바꿔치기한 요청부터 시작한다.
								
								
							2.Forward
						 		==> 원래 클라이언트의  요청 정보를 유지한 상태에서 
						 			화면에 보이는 문서만 바꾸는 기법으로 처리한다.
						 			
						 		따라서 원래 클라이언트가 준 정보는 기억하고있는 상태이다.
						 		새로고침하면 처음부터 다시 시작한다.
						 		즉, 클라이언트의 실제요청부터 다시시작한다.
						 		
						 		
						 
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						
					
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	